/* eslint-disable */
// tslint:disable
/**
 * Postcodes.io
 * Postcodes.io allows UK postcode data to be queried over a JSON HTTP API.

Postcodes.io is an open sourced project maintained by Ideal Postcodes.

It is a free resource, allowing developers to search, reverse geocode and extract UK postcode and associated data.

 *
 * OpenAPI spec version: 1.0.0
 * Contact: 
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import { BASE_PATH, COLLECTION_FORMATS, FetchAPI, FetchArgs, BaseAPI, RequiredError, defaultFetch } from "./runtime";
import { Api } from "./models";
import { btoa } from "abab";
import { Buffer } from "buffer";
import { Headers, RequestInit, Response } from "node-fetch";
import { URLSearchParams } from "url";
import FormData from "form-data";

export type FactoryFunction<T> = (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) => T;

export namespace OutcodesApi {
	export interface NearestOutcodeParameters {
		outcode: string
		/**
		 * @description <p>Limits number of outcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @type {number}
		 */
		limit?: number
		/**
		 * @description <p>Limits number of outcodes matches to return. Defaults to 5000m. Needs to be less than 25,000m.</p>
		 * @type {number}
		 */
		radius?: number
	}
	export type NearestOutcodeResponse =
		| NearestOutcode200Response
		| NearestOutcode404Response
	
	export interface NearestOutcode200Response {
		status: 200
		contentType: 'application/json'
		body: Api.NearestOutcode200Response
		headers?: undefined
	}
	
	export interface NearestOutcode404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ServerErrorResponseBody
		headers?: undefined
	}
	
	export interface OutcodeReverseGeocodingParameters {
		/**
		 * @type {number}
		 */
		lon: number
		/**
		 * @type {number}
		 */
		lat: number
		/**
		 * @description <p>Limits number of outcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @type {number}
		 */
		limit?: number
		/**
		 * @description <p>Limits number of outcodes matches to return. Defaults to 5000m. Needs to be less than 25,000m.</p>
		 * @type {number}
		 */
		radius?: number
	}
	export type OutcodeReverseGeocodingResponse =
		| OutcodeReverseGeocoding200Response
		| OutcodeReverseGeocoding400Response
	
	export interface OutcodeReverseGeocoding200Response {
		status: 200
		contentType: 'application/json'
		body: Api.OutcodeReverseGeocoding200Response
		headers?: undefined
	}
	
	export interface OutcodeReverseGeocoding400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ServerErrorResponseBody
		headers?: undefined
	}
	
	export type OutwardCodeLookupResponse =
		| OutwardCodeLookup200Response
		| OutwardCodeLookup404Response
	
	export interface OutwardCodeLookup200Response {
		status: 200
		contentType: 'application/json'
		body: Api.OutwardCodeLookup200Response
		headers?: undefined
	}
	
	export interface OutwardCodeLookup404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ServerErrorResponseBody
		headers?: undefined
	}
	
}

/**
 * OutcodesApi - fetch parameter creator
 * @export
 */
export const OutcodesApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Returns nearest outcodes for a given outcode.</p>
		 * @summary Nearest Outcode
		 * @param {string} outcode
		 * @param {number} [limit] <p>Limits number of outcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @param {number} [radius] <p>Limits number of outcodes matches to return. Defaults to 5000m. Needs to be less than 25,000m.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		nearestOutcode(__params: OutcodesApi.NearestOutcodeParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'outcode' is not null or undefined
			if (__params.outcode === null || __params.outcode === undefined) {
				throw new RequiredError('outcode', 'Required parameter outcode was null or undefined when calling nearestOutcode.');
			}

			let localVarPath = `/outcodes/{outcode}/nearest`
				.replace('{outcode}', encodeURIComponent(String(__params.outcode)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			if (__params.radius !== undefined) {
				localVarQueryParameter.append('radius', String(__params.radius));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Returns nearest outcodes for a given longitude and latitude.</p>
		 * @summary Outcode Reverse Geocoding
		 * @param {number} lon
		 * @param {number} lat
		 * @param {number} [limit] <p>Limits number of outcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @param {number} [radius] <p>Limits number of outcodes matches to return. Defaults to 5000m. Needs to be less than 25,000m.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		outcodeReverseGeocoding(__params: OutcodesApi.OutcodeReverseGeocodingParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'lon' is not null or undefined
			if (__params.lon === null || __params.lon === undefined) {
				throw new RequiredError('lon', 'Required parameter lon was null or undefined when calling outcodeReverseGeocoding.');
			}
			// verify required parameter 'lat' is not null or undefined
			if (__params.lat === null || __params.lat === undefined) {
				throw new RequiredError('lat', 'Required parameter lat was null or undefined when calling outcodeReverseGeocoding.');
			}

			let localVarPath = `/outcodes`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (__params.lon !== undefined) {
				localVarQueryParameter.append('lon', String(__params.lon));
			}

			if (__params.lat !== undefined) {
				localVarQueryParameter.append('lat', String(__params.lat));
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			if (__params.radius !== undefined) {
				localVarQueryParameter.append('radius', String(__params.radius));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Geolocation data for the centroid of the outward code specified. The outward code represents the first half of any postcode (separated by a space).</p>
		 * @summary Outward Code Lookup
		 * @param {string} outcode
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		outwardCodeLookup(outcode: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'outcode' is not null or undefined
			if (outcode === null || outcode === undefined) {
				throw new RequiredError('outcode', 'Required parameter outcode was null or undefined when calling outwardCodeLookup.');
			}

			let localVarPath = `/outcodes/{outcode}`
				.replace('{outcode}', encodeURIComponent(String(outcode)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * OutcodesApi - functional programming interface
 * @export
 */
export const OutcodesApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Returns nearest outcodes for a given outcode.</p>
		 * @summary Nearest Outcode
		 * @param {string} outcode
		 * @param {number} [limit] <p>Limits number of outcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @param {number} [radius] <p>Limits number of outcodes matches to return. Defaults to 5000m. Needs to be less than 25,000m.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		nearestOutcode(__params: OutcodesApi.NearestOutcodeParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<OutcodesApi.NearestOutcodeResponse> {
			const localVarFetchArgs = OutcodesApiFetchParamCreator(configuration).nearestOutcode(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.NearestOutcode200Response,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: 404,
							contentType: 'application/json',
							body: await response.json() as Api.ServerErrorResponseBody,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>Returns nearest outcodes for a given longitude and latitude.</p>
		 * @summary Outcode Reverse Geocoding
		 * @param {number} lon
		 * @param {number} lat
		 * @param {number} [limit] <p>Limits number of outcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @param {number} [radius] <p>Limits number of outcodes matches to return. Defaults to 5000m. Needs to be less than 25,000m.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		outcodeReverseGeocoding(__params: OutcodesApi.OutcodeReverseGeocodingParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<OutcodesApi.OutcodeReverseGeocodingResponse> {
			const localVarFetchArgs = OutcodesApiFetchParamCreator(configuration).outcodeReverseGeocoding(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.OutcodeReverseGeocoding200Response,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: 400,
							contentType: 'application/json',
							body: await response.json() as Api.ServerErrorResponseBody,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>Geolocation data for the centroid of the outward code specified. The outward code represents the first half of any postcode (separated by a space).</p>
		 * @summary Outward Code Lookup
		 * @param {string} outcode
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		outwardCodeLookup(outcode: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<OutcodesApi.OutwardCodeLookupResponse> {
			const localVarFetchArgs = OutcodesApiFetchParamCreator(configuration).outwardCodeLookup(outcode, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.OutwardCodeLookup200Response,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: 404,
							contentType: 'application/json',
							body: await response.json() as Api.ServerErrorResponseBody,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * OutcodesApi - factory interface
 * @export
 */
export const OutcodesApiFactory: FactoryFunction<OutcodesApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new OutcodesApi(configuration, basePath, fetch);
};

/**
 * OutcodesApi - object-oriented interface
 * @export
 * @class OutcodesApi
 * @extends {BaseAPI}
 */
export class OutcodesApi extends BaseAPI {
	/**
	 * <p>Returns nearest outcodes for a given outcode.</p>
	 * @summary Nearest Outcode
	 * @param {string} outcode
	 * @param {number} [limit] <p>Limits number of outcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
	 * @param {number} [radius] <p>Limits number of outcodes matches to return. Defaults to 5000m. Needs to be less than 25,000m.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public nearestOutcode(__params: OutcodesApi.NearestOutcodeParameters, options?: RequestInit) {
		return OutcodesApiFp(this.configuration).nearestOutcode(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Returns nearest outcodes for a given longitude and latitude.</p>
	 * @summary Outcode Reverse Geocoding
	 * @param {number} lon
	 * @param {number} lat
	 * @param {number} [limit] <p>Limits number of outcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
	 * @param {number} [radius] <p>Limits number of outcodes matches to return. Defaults to 5000m. Needs to be less than 25,000m.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public outcodeReverseGeocoding(__params: OutcodesApi.OutcodeReverseGeocodingParameters, options?: RequestInit) {
		return OutcodesApiFp(this.configuration).outcodeReverseGeocoding(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Geolocation data for the centroid of the outward code specified. The outward code represents the first half of any postcode (separated by a space).</p>
	 * @summary Outward Code Lookup
	 * @param {string} outcode
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public outwardCodeLookup(outcode: string, options?: RequestInit) {
		return OutcodesApiFp(this.configuration).outwardCodeLookup(outcode, options)(this.fetch, this.basePath);
	}

}
export namespace PlacesApi {
	export type PlaceLookupResponse =
		| PlaceLookup200Response
		| PlaceLookup404Response
	
	export interface PlaceLookup200Response {
		status: 200
		contentType: 'application/json'
		body: Api.PlaceLookup200Response
		headers?: undefined
	}
	
	export interface PlaceLookup404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ServerErrorResponseBody
		headers?: undefined
	}
	
	export interface PlaceQueryParameters {
		q?: string
		query?: string
		/**
		 * @description <p>Limits number of places matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @type {number}
		 */
		limit?: number
	}
	export type PlaceQueryResponse =
		| PlaceQuery200Response
		| PlaceQuery400Response
	
	export interface PlaceQuery200Response {
		status: 200
		contentType: 'application/json'
		body: Api.PlaceQuery200Response
		headers?: undefined
	}
	
	export interface PlaceQuery400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ServerErrorResponseBody
		headers?: undefined
	}
	
}

/**
 * PlacesApi - fetch parameter creator
 * @export
 */
export const PlacesApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Find a place by OSGB code (e.g. &quot;osgb4000000074564391&quot;). Returns all available data if found. Returns 404 if place does not exist.</p>
		 * @summary Place Lookup
		 * @param {string} code
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		placeLookup(code: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'code' is not null or undefined
			if (code === null || code === undefined) {
				throw new RequiredError('code', 'Required parameter code was null or undefined when calling placeLookup.');
			}

			let localVarPath = `/places/{code}`
				.replace('{code}', encodeURIComponent(String(code)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Submit a place query and receive a complete list of places matches and associated data.</p>
		 * @summary Place Query
		 * @param {string} [q]
		 * @param {string} [query]
		 * @param {number} [limit] <p>Limits number of places matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		placeQuery(__params: PlacesApi.PlaceQueryParameters, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/places`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (__params.q !== undefined) {
				localVarQueryParameter.append('q', String(__params.q));
			}

			if (__params.query !== undefined) {
				localVarQueryParameter.append('query', String(__params.query));
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * PlacesApi - functional programming interface
 * @export
 */
export const PlacesApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Find a place by OSGB code (e.g. &quot;osgb4000000074564391&quot;). Returns all available data if found. Returns 404 if place does not exist.</p>
		 * @summary Place Lookup
		 * @param {string} code
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		placeLookup(code: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PlacesApi.PlaceLookupResponse> {
			const localVarFetchArgs = PlacesApiFetchParamCreator(configuration).placeLookup(code, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.PlaceLookup200Response,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: 404,
							contentType: 'application/json',
							body: await response.json() as Api.ServerErrorResponseBody,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>Submit a place query and receive a complete list of places matches and associated data.</p>
		 * @summary Place Query
		 * @param {string} [q]
		 * @param {string} [query]
		 * @param {number} [limit] <p>Limits number of places matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		placeQuery(__params: PlacesApi.PlaceQueryParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PlacesApi.PlaceQueryResponse> {
			const localVarFetchArgs = PlacesApiFetchParamCreator(configuration).placeQuery(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.PlaceQuery200Response,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: 400,
							contentType: 'application/json',
							body: await response.json() as Api.ServerErrorResponseBody,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * PlacesApi - factory interface
 * @export
 */
export const PlacesApiFactory: FactoryFunction<PlacesApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new PlacesApi(configuration, basePath, fetch);
};

/**
 * PlacesApi - object-oriented interface
 * @export
 * @class PlacesApi
 * @extends {BaseAPI}
 */
export class PlacesApi extends BaseAPI {
	/**
	 * <p>Find a place by OSGB code (e.g. &quot;osgb4000000074564391&quot;). Returns all available data if found. Returns 404 if place does not exist.</p>
	 * @summary Place Lookup
	 * @param {string} code
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public placeLookup(code: string, options?: RequestInit) {
		return PlacesApiFp(this.configuration).placeLookup(code, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Submit a place query and receive a complete list of places matches and associated data.</p>
	 * @summary Place Query
	 * @param {string} [q]
	 * @param {string} [query]
	 * @param {number} [limit] <p>Limits number of places matches to return. Defaults to 10. Needs to be less than 100.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public placeQuery(__params: PlacesApi.PlaceQueryParameters, options?: RequestInit) {
		return PlacesApiFp(this.configuration).placeQuery(__params, options)(this.fetch, this.basePath);
	}

}
export namespace PostcodesApi {
	export interface BulkPostcodeLookupOrBulkReverseGeocodingParameters {
		filter?: string
		/**
		 * @type {number}
		 */
		limit?: number
		/**
		 * @type {number}
		 */
		radius?: number
		/**
		 * @description <p>Applies a global widesearch parameter to all geolocation lookup objects. Defaults to <code>false</code>.</p>
		 * @type {boolean}
		 */
		widesearch?: boolean
	}
	export type BulkPostcodeLookupOrBulkReverseGeocodingResponse =
		| BulkPostcodeLookupOrBulkReverseGeocoding200Response
		| BulkPostcodeLookupOrBulkReverseGeocoding400Response
	
	export interface BulkPostcodeLookupOrBulkReverseGeocoding200Response {
		status: 200
		contentType: 'application/json'
		body: Api.BulkPostcodeLookupOrBulkReverseGeocoding200Response
		headers?: undefined
	}
	
	export interface BulkPostcodeLookupOrBulkReverseGeocoding400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ServerErrorResponseBody
		headers?: undefined
	}
	
	export interface NearestPostcodeParameters {
		postcode: string
		/**
		 * @type {number}
		 */
		limit?: number
		/**
		 * @type {number}
		 */
		radius?: number
	}
	export type NearestPostcodeResponse =
		| NearestPostcode200Response
		| NearestPostcode404Response
	
	export interface NearestPostcode200Response {
		status: 200
		contentType: 'application/json'
		body: Api.NearestPostcode200Response
		headers?: undefined
	}
	
	export interface NearestPostcode404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ServerErrorResponseBody
		headers?: undefined
	}
	
	export interface PostcodeAutocompleteParameters {
		postcode: string
		/**
		 * @type {number}
		 */
		limit?: number
	}
	export type PostcodeAutocompleteResponse =
		| PostcodeAutocomplete200Response
	
	export interface PostcodeAutocomplete200Response {
		status: 200
		contentType: 'application/json'
		body: Api.PostcodeAutocomplete200Response
		headers?: undefined
	}
	
	export type PostcodeLookupResponse =
		| PostcodeLookup200Response
		| PostcodeLookup404Response
	
	export interface PostcodeLookup200Response {
		status: 200
		contentType: 'application/json'
		body: Api.PostcodeLookup200Response
		headers?: undefined
	}
	
	export interface PostcodeLookup404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ServerErrorResponseBody
		headers?: undefined
	}
	
	export type PostcodeValidationResponse =
		| PostcodeValidation200Response
	
	export interface PostcodeValidation200Response {
		status: 200
		contentType: 'application/json'
		body: Api.PostcodeValidation200Response
		headers?: undefined
	}
	
	export interface ReverseGeocodingLegacyParameters {
		/**
		 * @type {number}
		 */
		latitude: number
		/**
		 * @type {number}
		 */
		longitude: number
		/**
		 * @description <p>Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @type {number}
		 */
		limit?: number
		/**
		 * @description <p>Limits number of postcodes matches to return. Defaults to 100m. Needs to be less than 2,000m.</p>
		 * @type {number}
		 */
		radius?: number
		/**
		 * @description <p>Search up to 20km radius, but subject to a maximum of 10 results. Since lookups over a wide area can be very expensive, we&#39;ve created this method to allow you choose to make the trade off between search radius and number of results. Defaults to false. When enabled, radius and limits over 10 are ignored. </p>
		 * @type {boolean}
		 */
		widesearch?: boolean
	}
	export type ReverseGeocodingLegacyResponse =
		| ReverseGeocodingLegacy200Response
		| ReverseGeocodingLegacy400Response
	
	export interface ReverseGeocodingLegacy200Response {
		status: 200
		contentType: 'application/json'
		body: Api.ReverseGeocodingLegacy200Response
		headers?: undefined
	}
	
	export interface ReverseGeocodingLegacy400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ServerErrorResponseBody
		headers?: undefined
	}
	
	export interface ReverseGeocodingOrPostcodeQueryParameters {
		/**
		 * @type {number}
		 */
		lat?: number
		/**
		 * @description <p>Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @type {number}
		 */
		limit?: number
		/**
		 * @type {number}
		 */
		lon?: number
		q?: string
		query?: string
		/**
		 * @description <p>Limits number of postcodes matches to return. Defaults to 100m. Needs to be less than 2,000m.</p>
		 * @type {number}
		 */
		radius?: number
		/**
		 * @description <p>Search up to 20km radius, but subject to a maximum of 10 results. Since lookups over a wide area can be very expensive, we&#39;ve created this method to allow you choose to make the trade off between search radius and number of results. Defaults to false. When enabled, radius and limits over 10 are ignored. </p>
		 * @type {boolean}
		 */
		widesearch?: boolean
	}
	export type ReverseGeocodingOrPostcodeQueryResponse =
		| ReverseGeocodingOrPostcodeQuery200Response
		| ReverseGeocodingOrPostcodeQuery400Response
	
	export interface ReverseGeocodingOrPostcodeQuery200Response {
		status: 200
		contentType: 'application/json'
		body: Api.ReverseGeocodingOrPostcodeQuery200Response
		headers?: undefined
	}
	
	export interface ReverseGeocodingOrPostcodeQuery400Response {
		status: 400
		contentType: 'application/json'
		body: Api.ServerErrorResponseBody
		headers?: undefined
	}
	
}

/**
 * PostcodesApi - fetch parameter creator
 * @export
 */
export const PostcodesApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <h3 id="bulk-postcode-lookup">Bulk Postcode Lookup</h3>
		 * <p>Accepts a JSON object containing an array of postcodes. Returns a list of matching postcodes and respective available data.</p>
		 * <p>Be sure to submit JSON requests setting <code>Content-Type</code> to <code>application/json</code></p>
		 * <p>Accepts up to 100 postcodes.</p>
		 * <h3 id="bulk-reverse-geocoding">Bulk Reverse Geocoding</h3>
		 * <p>Bulk translates geolocations into Postcodes. Accepts up to 100 geolocations.</p>
		 * @summary Bulk Postcode Lookup / Bulk Reverse Geocoding
		 * @param {string} [filter]
		 * @param {number} [limit]
		 * @param {number} [radius]
		 * @param {boolean} [widesearch] <p>Applies a global widesearch parameter to all geolocation lookup objects. Defaults to <code>false</code>.</p>
		 * @param {Api.BulkPostcodeLookupOrBulkReverseGeocodingRequest.ObjectValue | Api.BulkPostcodeLookupOrBulkReverseGeocodingRequest.ObjectValue2} request <h3 id="bulk-postcode-lookup">Bulk Postcode Lookup</h3>
		 *   <p>This method requires a JSON object containing an array of postcodes to be posted</p>
		 *   <h3 id="bulk-reverse-geocoding">Bulk Reverse Geocoding</h3>
		 *   <p>Bulk translates geolocations into Postcodes. Accepts up to 100 geolocations.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		bulkPostcodeLookupOrBulkReverseGeocoding(__params: PostcodesApi.BulkPostcodeLookupOrBulkReverseGeocodingParameters, request: Api.BulkPostcodeLookupOrBulkReverseGeocodingRequest.ObjectValue | Api.BulkPostcodeLookupOrBulkReverseGeocodingRequest.ObjectValue2, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling bulkPostcodeLookupOrBulkReverseGeocoding.');
			}

			let localVarPath = `/postcodes`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (__params.filter !== undefined) {
				localVarQueryParameter.append('filter', String(__params.filter));
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			if (__params.radius !== undefined) {
				localVarQueryParameter.append('radius', String(__params.radius));
			}

			if (__params.widesearch !== undefined) {
				localVarQueryParameter.append('widesearch', String(__params.widesearch));
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Returns nearest postcodes for a given postcode.</p>
		 * @summary Nearest Postcode
		 * @param {string} postcode
		 * @param {number} [limit]
		 * @param {number} [radius]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		nearestPostcode(__params: PostcodesApi.NearestPostcodeParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'postcode' is not null or undefined
			if (__params.postcode === null || __params.postcode === undefined) {
				throw new RequiredError('postcode', 'Required parameter postcode was null or undefined when calling nearestPostcode.');
			}

			let localVarPath = `/postcodes/{postcode}/nearest`
				.replace('{postcode}', encodeURIComponent(String(__params.postcode)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			if (__params.radius !== undefined) {
				localVarQueryParameter.append('radius', String(__params.radius));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Convenience method to return an list of matching postcodes.</p>
		 * @summary Postcode Autocomplete
		 * @param {string} postcode
		 * @param {number} [limit]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postcodeAutocomplete(__params: PostcodesApi.PostcodeAutocompleteParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'postcode' is not null or undefined
			if (__params.postcode === null || __params.postcode === undefined) {
				throw new RequiredError('postcode', 'Required parameter postcode was null or undefined when calling postcodeAutocomplete.');
			}

			let localVarPath = `/postcodes/{postcode}/autocomplete`
				.replace('{postcode}', encodeURIComponent(String(__params.postcode)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>This uniquely identifies a postcode.</p>
		 * <p>Returns a single postcode entity for a given postcode (case, space insensitive).</p>
		 * <p>If no postcode is found it returns &quot;404&quot; response code.</p>
		 * @summary Postcode Lookup
		 * @param {string} postcode
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postcodeLookup(postcode: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'postcode' is not null or undefined
			if (postcode === null || postcode === undefined) {
				throw new RequiredError('postcode', 'Required parameter postcode was null or undefined when calling postcodeLookup.');
			}

			let localVarPath = `/postcodes/{postcode}`
				.replace('{postcode}', encodeURIComponent(String(postcode)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Convenience method to validate a postcode. Returns true or false (meaning valid or invalid respectively)</p>
		 * @summary Postcode Validation
		 * @param {string} postcode
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postcodeValidation(postcode: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'postcode' is not null or undefined
			if (postcode === null || postcode === undefined) {
				throw new RequiredError('postcode', 'Required parameter postcode was null or undefined when calling postcodeValidation.');
			}

			let localVarPath = `/postcodes/{postcode}/validate`
				.replace('{postcode}', encodeURIComponent(String(postcode)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Returns nearest postcodes for a given longitude and latitude.</p>
		 * @summary Reverse Geocoding (Legacy)
		 * @param {number} latitude
		 * @param {number} longitude
		 * @param {number} [limit] <p>Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @param {number} [radius] <p>Limits number of postcodes matches to return. Defaults to 100m. Needs to be less than 2,000m.</p>
		 * @param {boolean} [widesearch] <p>Search up to 20km radius, but subject to a maximum of 10 results. Since lookups over a wide area can be very expensive, we&#39;ve created this method to allow you choose to make the trade off between search radius and number of results. Defaults to false. When enabled, radius and limits over 10 are ignored. </p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 * @deprecated
		 */
		reverseGeocodingLegacy(__params: PostcodesApi.ReverseGeocodingLegacyParameters, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'latitude' is not null or undefined
			if (__params.latitude === null || __params.latitude === undefined) {
				throw new RequiredError('latitude', 'Required parameter latitude was null or undefined when calling reverseGeocodingLegacy.');
			}
			// verify required parameter 'longitude' is not null or undefined
			if (__params.longitude === null || __params.longitude === undefined) {
				throw new RequiredError('longitude', 'Required parameter longitude was null or undefined when calling reverseGeocodingLegacy.');
			}

			let localVarPath = `/postcodes/lon/{longitude}/lat/{latitude}`
				.replace('{latitude}', encodeURIComponent(String(__params.latitude)))
				.replace('{longitude}', encodeURIComponent(String(__params.longitude)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			if (__params.radius !== undefined) {
				localVarQueryParameter.append('radius', String(__params.radius));
			}

			if (__params.widesearch !== undefined) {
				localVarQueryParameter.append('widesearch', String(__params.widesearch));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <h3 id="reverse-geocoding">Reverse Geocoding</h3>
		 * <p>Returns nearest postcodes for a given longitude and latitude.</p>
		 * <h4 id="required-query-parameters">Required Query Parameters</h4>
		 * <p><code>lon=</code> Longitude</p>
		 * <p><code>lat=</code> Latitude</p>
		 * <h4 id="optional-query-parameters">Optional Query Parameters</h4>
		 * <p><code>limit=</code> (not required) Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * <p><code>radius=</code> (not required) Limits number of postcodes matches to return. Defaults to 100m. Needs to be less than 2,000m.</p>
		 * <p><code>widesearch=</code> (not required) Search up to 20km radius, but subject to a maximum of 10 results. Since lookups over a wide area can be very expensive, we&#39;ve created this method to allow you choose to make the trade off between search radius and number of results. Defaults to false. When enabled, radius and limits over 10 are ignored.</p>
		 * <h3 id="postcode-query">Postcode Query</h3>
		 * <p>Submit a postcode query and receive a complete list of postcode matches and all associated postcode data.</p>
		 * <p>This is essentially a postcode search which prefix matches and returns postcodes in sorted order (case insensitive)</p>
		 * <p>This method is space sensitive, i.e. it detects for spaces between outward and inward parts of the postcode (some examples detailed <a href="https://github.com/ideal-postcodes/postcodes.io/issues/44">in this issue</a>)</p>
		 * <p>The result set can either be empty or populated with up to 100 postcode entities. Either way it will always return a 200 response code</p>
		 * <h4 id="required-query-parameters-1">Required Query Parameters</h4>
		 * <p><code>q=</code> Postcode search</p>
		 * <h4 id="optional-query-parameters-1">Optional Query Parameters</h4>
		 * <p><code>query=</code> (not required) aliases to <code>q=</code></p>
		 * <p><code>limit=</code> (not required) Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100. </p>
		 * @summary Reverse Geocoding / Postcode Query
		 * @param {number} [lat]
		 * @param {number} [limit] <p>Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @param {number} [lon]
		 * @param {string} [q]
		 * @param {string} [query]
		 * @param {number} [radius] <p>Limits number of postcodes matches to return. Defaults to 100m. Needs to be less than 2,000m.</p>
		 * @param {boolean} [widesearch] <p>Search up to 20km radius, but subject to a maximum of 10 results. Since lookups over a wide area can be very expensive, we&#39;ve created this method to allow you choose to make the trade off between search radius and number of results. Defaults to false. When enabled, radius and limits over 10 are ignored. </p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		reverseGeocodingOrPostcodeQuery(__params: PostcodesApi.ReverseGeocodingOrPostcodeQueryParameters, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/postcodes`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (__params.lat !== undefined) {
				localVarQueryParameter.append('lat', String(__params.lat));
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			if (__params.lon !== undefined) {
				localVarQueryParameter.append('lon', String(__params.lon));
			}

			if (__params.q !== undefined) {
				localVarQueryParameter.append('q', String(__params.q));
			}

			if (__params.query !== undefined) {
				localVarQueryParameter.append('query', String(__params.query));
			}

			if (__params.radius !== undefined) {
				localVarQueryParameter.append('radius', String(__params.radius));
			}

			if (__params.widesearch !== undefined) {
				localVarQueryParameter.append('widesearch', String(__params.widesearch));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * PostcodesApi - functional programming interface
 * @export
 */
export const PostcodesApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <h3 id="bulk-postcode-lookup">Bulk Postcode Lookup</h3>
		 * <p>Accepts a JSON object containing an array of postcodes. Returns a list of matching postcodes and respective available data.</p>
		 * <p>Be sure to submit JSON requests setting <code>Content-Type</code> to <code>application/json</code></p>
		 * <p>Accepts up to 100 postcodes.</p>
		 * <h3 id="bulk-reverse-geocoding">Bulk Reverse Geocoding</h3>
		 * <p>Bulk translates geolocations into Postcodes. Accepts up to 100 geolocations.</p>
		 * @summary Bulk Postcode Lookup / Bulk Reverse Geocoding
		 * @param {string} [filter]
		 * @param {number} [limit]
		 * @param {number} [radius]
		 * @param {boolean} [widesearch] <p>Applies a global widesearch parameter to all geolocation lookup objects. Defaults to <code>false</code>.</p>
		 * @param {Api.BulkPostcodeLookupOrBulkReverseGeocodingRequest.ObjectValue | Api.BulkPostcodeLookupOrBulkReverseGeocodingRequest.ObjectValue2} request <h3 id="bulk-postcode-lookup">Bulk Postcode Lookup</h3>
		 *   <p>This method requires a JSON object containing an array of postcodes to be posted</p>
		 *   <h3 id="bulk-reverse-geocoding">Bulk Reverse Geocoding</h3>
		 *   <p>Bulk translates geolocations into Postcodes. Accepts up to 100 geolocations.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		bulkPostcodeLookupOrBulkReverseGeocoding(__params: PostcodesApi.BulkPostcodeLookupOrBulkReverseGeocodingParameters, request: Api.BulkPostcodeLookupOrBulkReverseGeocodingRequest.ObjectValue | Api.BulkPostcodeLookupOrBulkReverseGeocodingRequest.ObjectValue2, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PostcodesApi.BulkPostcodeLookupOrBulkReverseGeocodingResponse> {
			const localVarFetchArgs = PostcodesApiFetchParamCreator(configuration).bulkPostcodeLookupOrBulkReverseGeocoding(__params, request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.BulkPostcodeLookupOrBulkReverseGeocoding200Response,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: 400,
							contentType: 'application/json',
							body: await response.json() as Api.ServerErrorResponseBody,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>Returns nearest postcodes for a given postcode.</p>
		 * @summary Nearest Postcode
		 * @param {string} postcode
		 * @param {number} [limit]
		 * @param {number} [radius]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		nearestPostcode(__params: PostcodesApi.NearestPostcodeParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PostcodesApi.NearestPostcodeResponse> {
			const localVarFetchArgs = PostcodesApiFetchParamCreator(configuration).nearestPostcode(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.NearestPostcode200Response,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: 404,
							contentType: 'application/json',
							body: await response.json() as Api.ServerErrorResponseBody,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>Convenience method to return an list of matching postcodes.</p>
		 * @summary Postcode Autocomplete
		 * @param {string} postcode
		 * @param {number} [limit]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postcodeAutocomplete(__params: PostcodesApi.PostcodeAutocompleteParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PostcodesApi.PostcodeAutocompleteResponse> {
			const localVarFetchArgs = PostcodesApiFetchParamCreator(configuration).postcodeAutocomplete(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.PostcodeAutocomplete200Response,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>This uniquely identifies a postcode.</p>
		 * <p>Returns a single postcode entity for a given postcode (case, space insensitive).</p>
		 * <p>If no postcode is found it returns &quot;404&quot; response code.</p>
		 * @summary Postcode Lookup
		 * @param {string} postcode
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postcodeLookup(postcode: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PostcodesApi.PostcodeLookupResponse> {
			const localVarFetchArgs = PostcodesApiFetchParamCreator(configuration).postcodeLookup(postcode, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.PostcodeLookup200Response,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: 404,
							contentType: 'application/json',
							body: await response.json() as Api.ServerErrorResponseBody,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>Convenience method to validate a postcode. Returns true or false (meaning valid or invalid respectively)</p>
		 * @summary Postcode Validation
		 * @param {string} postcode
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postcodeValidation(postcode: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PostcodesApi.PostcodeValidationResponse> {
			const localVarFetchArgs = PostcodesApiFetchParamCreator(configuration).postcodeValidation(postcode, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.PostcodeValidation200Response,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>Returns nearest postcodes for a given longitude and latitude.</p>
		 * @summary Reverse Geocoding (Legacy)
		 * @param {number} latitude
		 * @param {number} longitude
		 * @param {number} [limit] <p>Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @param {number} [radius] <p>Limits number of postcodes matches to return. Defaults to 100m. Needs to be less than 2,000m.</p>
		 * @param {boolean} [widesearch] <p>Search up to 20km radius, but subject to a maximum of 10 results. Since lookups over a wide area can be very expensive, we&#39;ve created this method to allow you choose to make the trade off between search radius and number of results. Defaults to false. When enabled, radius and limits over 10 are ignored. </p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 * @deprecated
		 */
		reverseGeocodingLegacy(__params: PostcodesApi.ReverseGeocodingLegacyParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PostcodesApi.ReverseGeocodingLegacyResponse> {
			const localVarFetchArgs = PostcodesApiFetchParamCreator(configuration).reverseGeocodingLegacy(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.ReverseGeocodingLegacy200Response,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: 400,
							contentType: 'application/json',
							body: await response.json() as Api.ServerErrorResponseBody,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <h3 id="reverse-geocoding">Reverse Geocoding</h3>
		 * <p>Returns nearest postcodes for a given longitude and latitude.</p>
		 * <h4 id="required-query-parameters">Required Query Parameters</h4>
		 * <p><code>lon=</code> Longitude</p>
		 * <p><code>lat=</code> Latitude</p>
		 * <h4 id="optional-query-parameters">Optional Query Parameters</h4>
		 * <p><code>limit=</code> (not required) Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * <p><code>radius=</code> (not required) Limits number of postcodes matches to return. Defaults to 100m. Needs to be less than 2,000m.</p>
		 * <p><code>widesearch=</code> (not required) Search up to 20km radius, but subject to a maximum of 10 results. Since lookups over a wide area can be very expensive, we&#39;ve created this method to allow you choose to make the trade off between search radius and number of results. Defaults to false. When enabled, radius and limits over 10 are ignored.</p>
		 * <h3 id="postcode-query">Postcode Query</h3>
		 * <p>Submit a postcode query and receive a complete list of postcode matches and all associated postcode data.</p>
		 * <p>This is essentially a postcode search which prefix matches and returns postcodes in sorted order (case insensitive)</p>
		 * <p>This method is space sensitive, i.e. it detects for spaces between outward and inward parts of the postcode (some examples detailed <a href="https://github.com/ideal-postcodes/postcodes.io/issues/44">in this issue</a>)</p>
		 * <p>The result set can either be empty or populated with up to 100 postcode entities. Either way it will always return a 200 response code</p>
		 * <h4 id="required-query-parameters-1">Required Query Parameters</h4>
		 * <p><code>q=</code> Postcode search</p>
		 * <h4 id="optional-query-parameters-1">Optional Query Parameters</h4>
		 * <p><code>query=</code> (not required) aliases to <code>q=</code></p>
		 * <p><code>limit=</code> (not required) Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100. </p>
		 * @summary Reverse Geocoding / Postcode Query
		 * @param {number} [lat]
		 * @param {number} [limit] <p>Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
		 * @param {number} [lon]
		 * @param {string} [q]
		 * @param {string} [query]
		 * @param {number} [radius] <p>Limits number of postcodes matches to return. Defaults to 100m. Needs to be less than 2,000m.</p>
		 * @param {boolean} [widesearch] <p>Search up to 20km radius, but subject to a maximum of 10 results. Since lookups over a wide area can be very expensive, we&#39;ve created this method to allow you choose to make the trade off between search radius and number of results. Defaults to false. When enabled, radius and limits over 10 are ignored. </p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		reverseGeocodingOrPostcodeQuery(__params: PostcodesApi.ReverseGeocodingOrPostcodeQueryParameters, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<PostcodesApi.ReverseGeocodingOrPostcodeQueryResponse> {
			const localVarFetchArgs = PostcodesApiFetchParamCreator(configuration).reverseGeocodingOrPostcodeQuery(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.ReverseGeocodingOrPostcodeQuery200Response,
						}
					}
					throw response;
				}
				if (response.status === 400) {
					if (mimeType === 'application/json') {
						return {
							status: 400,
							contentType: 'application/json',
							body: await response.json() as Api.ServerErrorResponseBody,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * PostcodesApi - factory interface
 * @export
 */
export const PostcodesApiFactory: FactoryFunction<PostcodesApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new PostcodesApi(configuration, basePath, fetch);
};

/**
 * PostcodesApi - object-oriented interface
 * @export
 * @class PostcodesApi
 * @extends {BaseAPI}
 */
export class PostcodesApi extends BaseAPI {
	/**
	 * <h3 id="bulk-postcode-lookup">Bulk Postcode Lookup</h3>
	 * <p>Accepts a JSON object containing an array of postcodes. Returns a list of matching postcodes and respective available data.</p>
	 * <p>Be sure to submit JSON requests setting <code>Content-Type</code> to <code>application/json</code></p>
	 * <p>Accepts up to 100 postcodes.</p>
	 * <h3 id="bulk-reverse-geocoding">Bulk Reverse Geocoding</h3>
	 * <p>Bulk translates geolocations into Postcodes. Accepts up to 100 geolocations.</p>
	 * @summary Bulk Postcode Lookup / Bulk Reverse Geocoding
	 * @param {string} [filter]
	 * @param {number} [limit]
	 * @param {number} [radius]
	 * @param {boolean} [widesearch] <p>Applies a global widesearch parameter to all geolocation lookup objects. Defaults to <code>false</code>.</p>
	 * @param {Api.BulkPostcodeLookupOrBulkReverseGeocodingRequest.ObjectValue | Api.BulkPostcodeLookupOrBulkReverseGeocodingRequest.ObjectValue2} request <h3 id="bulk-postcode-lookup">Bulk Postcode Lookup</h3>
	 *   <p>This method requires a JSON object containing an array of postcodes to be posted</p>
	 *   <h3 id="bulk-reverse-geocoding">Bulk Reverse Geocoding</h3>
	 *   <p>Bulk translates geolocations into Postcodes. Accepts up to 100 geolocations.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public bulkPostcodeLookupOrBulkReverseGeocoding(__params: PostcodesApi.BulkPostcodeLookupOrBulkReverseGeocodingParameters, request: Api.BulkPostcodeLookupOrBulkReverseGeocodingRequest.ObjectValue | Api.BulkPostcodeLookupOrBulkReverseGeocodingRequest.ObjectValue2, options?: RequestInit) {
		return PostcodesApiFp(this.configuration).bulkPostcodeLookupOrBulkReverseGeocoding(__params, request, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Returns nearest postcodes for a given postcode.</p>
	 * @summary Nearest Postcode
	 * @param {string} postcode
	 * @param {number} [limit]
	 * @param {number} [radius]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public nearestPostcode(__params: PostcodesApi.NearestPostcodeParameters, options?: RequestInit) {
		return PostcodesApiFp(this.configuration).nearestPostcode(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Convenience method to return an list of matching postcodes.</p>
	 * @summary Postcode Autocomplete
	 * @param {string} postcode
	 * @param {number} [limit]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public postcodeAutocomplete(__params: PostcodesApi.PostcodeAutocompleteParameters, options?: RequestInit) {
		return PostcodesApiFp(this.configuration).postcodeAutocomplete(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>This uniquely identifies a postcode.</p>
	 * <p>Returns a single postcode entity for a given postcode (case, space insensitive).</p>
	 * <p>If no postcode is found it returns &quot;404&quot; response code.</p>
	 * @summary Postcode Lookup
	 * @param {string} postcode
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public postcodeLookup(postcode: string, options?: RequestInit) {
		return PostcodesApiFp(this.configuration).postcodeLookup(postcode, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Convenience method to validate a postcode. Returns true or false (meaning valid or invalid respectively)</p>
	 * @summary Postcode Validation
	 * @param {string} postcode
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public postcodeValidation(postcode: string, options?: RequestInit) {
		return PostcodesApiFp(this.configuration).postcodeValidation(postcode, options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Returns nearest postcodes for a given longitude and latitude.</p>
	 * @summary Reverse Geocoding (Legacy)
	 * @param {number} latitude
	 * @param {number} longitude
	 * @param {number} [limit] <p>Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
	 * @param {number} [radius] <p>Limits number of postcodes matches to return. Defaults to 100m. Needs to be less than 2,000m.</p>
	 * @param {boolean} [widesearch] <p>Search up to 20km radius, but subject to a maximum of 10 results. Since lookups over a wide area can be very expensive, we&#39;ve created this method to allow you choose to make the trade off between search radius and number of results. Defaults to false. When enabled, radius and limits over 10 are ignored. </p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 * @deprecated
	 */
	public reverseGeocodingLegacy(__params: PostcodesApi.ReverseGeocodingLegacyParameters, options?: RequestInit) {
		return PostcodesApiFp(this.configuration).reverseGeocodingLegacy(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * <h3 id="reverse-geocoding">Reverse Geocoding</h3>
	 * <p>Returns nearest postcodes for a given longitude and latitude.</p>
	 * <h4 id="required-query-parameters">Required Query Parameters</h4>
	 * <p><code>lon=</code> Longitude</p>
	 * <p><code>lat=</code> Latitude</p>
	 * <h4 id="optional-query-parameters">Optional Query Parameters</h4>
	 * <p><code>limit=</code> (not required) Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
	 * <p><code>radius=</code> (not required) Limits number of postcodes matches to return. Defaults to 100m. Needs to be less than 2,000m.</p>
	 * <p><code>widesearch=</code> (not required) Search up to 20km radius, but subject to a maximum of 10 results. Since lookups over a wide area can be very expensive, we&#39;ve created this method to allow you choose to make the trade off between search radius and number of results. Defaults to false. When enabled, radius and limits over 10 are ignored.</p>
	 * <h3 id="postcode-query">Postcode Query</h3>
	 * <p>Submit a postcode query and receive a complete list of postcode matches and all associated postcode data.</p>
	 * <p>This is essentially a postcode search which prefix matches and returns postcodes in sorted order (case insensitive)</p>
	 * <p>This method is space sensitive, i.e. it detects for spaces between outward and inward parts of the postcode (some examples detailed <a href="https://github.com/ideal-postcodes/postcodes.io/issues/44">in this issue</a>)</p>
	 * <p>The result set can either be empty or populated with up to 100 postcode entities. Either way it will always return a 200 response code</p>
	 * <h4 id="required-query-parameters-1">Required Query Parameters</h4>
	 * <p><code>q=</code> Postcode search</p>
	 * <h4 id="optional-query-parameters-1">Optional Query Parameters</h4>
	 * <p><code>query=</code> (not required) aliases to <code>q=</code></p>
	 * <p><code>limit=</code> (not required) Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100. </p>
	 * @summary Reverse Geocoding / Postcode Query
	 * @param {number} [lat]
	 * @param {number} [limit] <p>Limits number of postcodes matches to return. Defaults to 10. Needs to be less than 100.</p>
	 * @param {number} [lon]
	 * @param {string} [q]
	 * @param {string} [query]
	 * @param {number} [radius] <p>Limits number of postcodes matches to return. Defaults to 100m. Needs to be less than 2,000m.</p>
	 * @param {boolean} [widesearch] <p>Search up to 20km radius, but subject to a maximum of 10 results. Since lookups over a wide area can be very expensive, we&#39;ve created this method to allow you choose to make the trade off between search radius and number of results. Defaults to false. When enabled, radius and limits over 10 are ignored. </p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public reverseGeocodingOrPostcodeQuery(__params: PostcodesApi.ReverseGeocodingOrPostcodeQueryParameters, options?: RequestInit) {
		return PostcodesApiFp(this.configuration).reverseGeocodingOrPostcodeQuery(__params, options)(this.fetch, this.basePath);
	}

}
export namespace RandomApi {
	export type RandomPlaceResponse =
		| RandomPlace200Response
	
	export interface RandomPlace200Response {
		status: 200
		contentType: 'application/json'
		body: Api.RandomPlace200Response
		headers?: undefined
	}
	
	export type RandomPostcodeResponse =
		| RandomPostcode200Response
	
	export interface RandomPostcode200Response {
		status: 200
		contentType: 'application/json'
		body: Api.RandomPostcode200Response
		headers?: undefined
	}
	
}

/**
 * RandomApi - fetch parameter creator
 * @export
 */
export const RandomApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Returns a random place and all associated data</p>
		 * @summary Random Place
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		randomPlace(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/random/places`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * <p>Returns a random postcode and all available data for that postcode.</p>
		 * @summary Random Postcode
		 * @param {string} [outcode] <p>Filters random postcodes by outcode. Returns null if invalid outcode.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		randomPostcode(outcode: string | undefined, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/random/postcodes`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (outcode !== undefined) {
				localVarQueryParameter.append('outcode', String(outcode));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * RandomApi - functional programming interface
 * @export
 */
export const RandomApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Returns a random place and all associated data</p>
		 * @summary Random Place
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		randomPlace(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<RandomApi.RandomPlaceResponse> {
			const localVarFetchArgs = RandomApiFetchParamCreator(configuration).randomPlace(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.RandomPlace200Response,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * <p>Returns a random postcode and all available data for that postcode.</p>
		 * @summary Random Postcode
		 * @param {string} [outcode] <p>Filters random postcodes by outcode. Returns null if invalid outcode.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		randomPostcode(outcode: string | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<RandomApi.RandomPostcodeResponse> {
			const localVarFetchArgs = RandomApiFetchParamCreator(configuration).randomPostcode(outcode, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.RandomPostcode200Response,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * RandomApi - factory interface
 * @export
 */
export const RandomApiFactory: FactoryFunction<RandomApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new RandomApi(configuration, basePath, fetch);
};

/**
 * RandomApi - object-oriented interface
 * @export
 * @class RandomApi
 * @extends {BaseAPI}
 */
export class RandomApi extends BaseAPI {
	/**
	 * <p>Returns a random place and all associated data</p>
	 * @summary Random Place
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public randomPlace(options?: RequestInit) {
		return RandomApiFp(this.configuration).randomPlace(options)(this.fetch, this.basePath);
	}

	/**
	 * <p>Returns a random postcode and all available data for that postcode.</p>
	 * @summary Random Postcode
	 * @param {string} [outcode] <p>Filters random postcodes by outcode. Returns null if invalid outcode.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public randomPostcode(outcode: string | undefined, options?: RequestInit) {
		return RandomApiFp(this.configuration).randomPostcode(outcode, options)(this.fetch, this.basePath);
	}

}
export namespace ScotlandApi {
	export type ScottishPostcodeLookupResponse =
		| ScottishPostcodeLookup200Response
		| ScottishPostcodeLookup404Response
	
	export interface ScottishPostcodeLookup200Response {
		status: 200
		contentType: 'application/json'
		body: Api.ScottishPostcodeLookup200Response
		headers?: undefined
	}
	
	export interface ScottishPostcodeLookup404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ServerErrorResponseBody
		headers?: undefined
	}
	
}

/**
 * ScotlandApi - fetch parameter creator
 * @export
 */
export const ScotlandApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Lookup a Scottish postcode. Returns SPD data associated with postcode. At the moment this is just Scottish Parliamentary Constituency.</p>
		 * <p>Returns 404 if postcode does not exist in SPD or is not valid. For postcodes not in SPD but in ONSPD, 404 is returned with error message <code>Postcode exists in ONSPD but not in SPD</code>.</p>
		 * @summary Scottish Postcode Lookup
		 * @param {string} postcode
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		scottishPostcodeLookup(postcode: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'postcode' is not null or undefined
			if (postcode === null || postcode === undefined) {
				throw new RequiredError('postcode', 'Required parameter postcode was null or undefined when calling scottishPostcodeLookup.');
			}

			let localVarPath = `/scotland/postcodes/{postcode}`
				.replace('{postcode}', encodeURIComponent(String(postcode)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ScotlandApi - functional programming interface
 * @export
 */
export const ScotlandApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Lookup a Scottish postcode. Returns SPD data associated with postcode. At the moment this is just Scottish Parliamentary Constituency.</p>
		 * <p>Returns 404 if postcode does not exist in SPD or is not valid. For postcodes not in SPD but in ONSPD, 404 is returned with error message <code>Postcode exists in ONSPD but not in SPD</code>.</p>
		 * @summary Scottish Postcode Lookup
		 * @param {string} postcode
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		scottishPostcodeLookup(postcode: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ScotlandApi.ScottishPostcodeLookupResponse> {
			const localVarFetchArgs = ScotlandApiFetchParamCreator(configuration).scottishPostcodeLookup(postcode, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.ScottishPostcodeLookup200Response,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: 404,
							contentType: 'application/json',
							body: await response.json() as Api.ServerErrorResponseBody,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * ScotlandApi - factory interface
 * @export
 */
export const ScotlandApiFactory: FactoryFunction<ScotlandApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ScotlandApi(configuration, basePath, fetch);
};

/**
 * ScotlandApi - object-oriented interface
 * @export
 * @class ScotlandApi
 * @extends {BaseAPI}
 */
export class ScotlandApi extends BaseAPI {
	/**
	 * <p>Lookup a Scottish postcode. Returns SPD data associated with postcode. At the moment this is just Scottish Parliamentary Constituency.</p>
	 * <p>Returns 404 if postcode does not exist in SPD or is not valid. For postcodes not in SPD but in ONSPD, 404 is returned with error message <code>Postcode exists in ONSPD but not in SPD</code>.</p>
	 * @summary Scottish Postcode Lookup
	 * @param {string} postcode
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public scottishPostcodeLookup(postcode: string, options?: RequestInit) {
		return ScotlandApiFp(this.configuration).scottishPostcodeLookup(postcode, options)(this.fetch, this.basePath);
	}

}
export namespace TerminatedPostcodesApi {
	export type TerminatedPostcodeLookupResponse =
		| TerminatedPostcodeLookup200Response
		| TerminatedPostcodeLookup404Response
	
	export interface TerminatedPostcodeLookup200Response {
		status: 200
		contentType: 'application/json'
		body: Api.TerminatedPostcodeLookup200Response
		headers?: undefined
	}
	
	export interface TerminatedPostcodeLookup404Response {
		status: 404
		contentType: 'application/json'
		body: Api.ServerErrorResponseBody
		headers?: undefined
	}
	
}

/**
 * TerminatedPostcodesApi - fetch parameter creator
 * @export
 */
export const TerminatedPostcodesApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Lookup a terminated postcode. Returns the postcode, year and month of termination. Returns 404 if postcode does not exist in our database of terminated postcodes or not valid.</p>
		 * @summary Terminated Postcode Lookup
		 * @param {string} postcode
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		terminatedPostcodeLookup(postcode: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'postcode' is not null or undefined
			if (postcode === null || postcode === undefined) {
				throw new RequiredError('postcode', 'Required parameter postcode was null or undefined when calling terminatedPostcodeLookup.');
			}

			let localVarPath = `/terminated_postcodes/{postcode}`
				.replace('{postcode}', encodeURIComponent(String(postcode)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * TerminatedPostcodesApi - functional programming interface
 * @export
 */
export const TerminatedPostcodesApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Lookup a terminated postcode. Returns the postcode, year and month of termination. Returns 404 if postcode does not exist in our database of terminated postcodes or not valid.</p>
		 * @summary Terminated Postcode Lookup
		 * @param {string} postcode
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		terminatedPostcodeLookup(postcode: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<TerminatedPostcodesApi.TerminatedPostcodeLookupResponse> {
			const localVarFetchArgs = TerminatedPostcodesApiFetchParamCreator(configuration).terminatedPostcodeLookup(postcode, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.TerminatedPostcodeLookup200Response,
						}
					}
					throw response;
				}
				if (response.status === 404) {
					if (mimeType === 'application/json') {
						return {
							status: 404,
							contentType: 'application/json',
							body: await response.json() as Api.ServerErrorResponseBody,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * TerminatedPostcodesApi - factory interface
 * @export
 */
export const TerminatedPostcodesApiFactory: FactoryFunction<TerminatedPostcodesApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new TerminatedPostcodesApi(configuration, basePath, fetch);
};

/**
 * TerminatedPostcodesApi - object-oriented interface
 * @export
 * @class TerminatedPostcodesApi
 * @extends {BaseAPI}
 */
export class TerminatedPostcodesApi extends BaseAPI {
	/**
	 * <p>Lookup a terminated postcode. Returns the postcode, year and month of termination. Returns 404 if postcode does not exist in our database of terminated postcodes or not valid.</p>
	 * @summary Terminated Postcode Lookup
	 * @param {string} postcode
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public terminatedPostcodeLookup(postcode: string, options?: RequestInit) {
		return TerminatedPostcodesApiFp(this.configuration).terminatedPostcodeLookup(postcode, options)(this.fetch, this.basePath);
	}

}

/**
 * We sometimes represent dates as strings (in models) and as Dates (in parameters) so this
 * function converts them both to a string.
 */
function dateToString(value: Date | string | undefined): string | undefined {
	if (value instanceof Date) {
		return value.toISOString();
	} else if (typeof value === 'string') {
		return value;
	} else {
		return undefined;
	}
}
